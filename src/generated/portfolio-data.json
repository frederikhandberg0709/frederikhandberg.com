[
  {
    "slug": "semester-project-3",
    "title": "Semester Project 3",
    "date": "2025-04-17",
    "excerpt": "This project was developed as part of our third semester project (SEP3) for my **Software Engineering** degree.",
    "author": "Frederik Handberg",
    "coverImage": "/Blazor_Properties.jpeg",
    "tags": [
      "Java Spring Boot",
      "SignalR",
      "Blazor",
      "JavaFX",
      "PostgreSQL"
    ],
    "readingTime": "7 min read",
    "content": "\r\nThe goal of the semester project was to design and implement a distributed system consisting of at least two servers. Our team chose to build a system for a fictional real estate agency called **Real Estate Plus**.\r\n\r\nGitHub repository: [https://github.com/frederikhandberg0709/SEP3](https://github.com/frederikhandberg0709/SEP3)\r\n\r\n## Project Structure\r\n\r\nThe project is structured as follows:\r\n\r\n- `/Blazor`: A Blazor web application for customers.\r\n- `/GUI`: A JavaFX desktop application designed for administrative users.\r\n- `/restful-server`: A Java Spring Boot REST server that handles backend operations and API requests.\r\n- `/signalr-server`: A SignalR server that delivers real-time notifications to the Blazor web application.\r\n\r\n## Functional Requirements\r\n\r\nThe system was designed to meet the following functional requirements defined through user stories. Each user story represents a specific feature written to reflect the user's goals and interactions with the system.\r\n\r\n**Create user account:** As a customer, I want to have the ability to create an account, so that I can access extra features like save bookmarks and book an agent.\r\n\r\n**Create administrator account:** As an administrator, I want to have the ability to create an account, so that I can manage properties, bookings, and agents.\r\n\r\n**Update user information:** As a customer, I want to be able to update my user account details, so that the agency can still contact me if my information changes.\r\n\r\n**Property filters:** As a customer, I want to have the ability to use filters such as, property type, so that I can find a property that matches my needs.\r\n\r\n**Book agent:** As a customer, I want to be able to book an appointment with an agent, so that I can receive further information and ask questions about a specific property.\r\n\r\n**Bookmark property listings:** As a customer, I want to be able to bookmark listings, so that I can easily revisit and review them later.\r\n\r\n**Real-time notifications:** As a customer, I want to receive notifications about my bookmarked properties, so that I can stay updated on any changes to them.\r\n\r\n**Search in admin dashboard:** As an administrator, I want to be able to search for property listings, so that I can quickly find the specific property I'm looking for.\r\n\r\n**Create property listing:** As an administrator, I want to be able to create new property listings, so that they can be added to the website.\r\n\r\n**Upload property images:** As an administrator, I want to be able to upload images of properties, so that customers can visually assess whether they are interested in a property.\r\n\r\n**Update property details:** As an administrator, I want to be able to update the details of property listings, so that I can ensure all information remains accurate and up to date.\r\n\r\n**Delete property listing:** As an administrator, I want to be able to delete property listings, so that outdated or irrelevant listings no longer appear to customers.\r\n\r\n## System Architecture\r\n\r\nThis project consists of five subsystems:\r\n\r\n![High-level system architecture diagram](/High_level_system_architecture.png)\r\n\r\n### PostgreSQL database\r\n\r\nThe PostgreSQL database is he data store for the entire system. It sores all the domain data such as:\r\n\r\n- User accounts.\r\n- Property listings.\r\n- Bookmarks.\r\n- Bookings.\r\n- Agents.\r\n\r\nThe database is exclusively accessed by the Spring Boot REST server.\r\n\r\n### Spring Boot REST server\r\n\r\nThe REST server built with Java Spring Boot is the backend of the system.\r\n\r\nIt acts as the middleman and is responsible for:\r\n\r\n- Handling HTTP requests from the Blazor web app and the JavaFX desktop app.\r\n- Performs authentication and authorization using Spring Security.\r\n- Writing and fetching data from the database.\r\n- Notifies the SignalR server when prices of a property changes.\r\n\r\n### SignalR notification server\r\n\r\nThe SignalR server is responsible for handling real-time communication with the Blazor web application.\r\n\r\n### JavaFX desktop application\r\n\r\nThe JavaFX desktop application is made for administrators of the real estate agency who manage the backend data.\r\n\r\nThe app provides a GUI to:\r\n\r\n- Create new accounts for admins.\r\n- Create, update, and delete property listings.\r\n- Manage agents.\r\n- View booking appointments.\r\n\r\nThe JavaFX desktop app is communicating with the REST API for all HTTP requests. Administrator accounts are assigned the `ADMIN` role.\r\n\r\n### Blazor web application\r\n\r\nThe Blazor web application is the frontend for customers.\r\n\r\nIt allows users to:\r\n\r\n- Register a new customer account.\r\n- Browse and bookmark property listings.\r\n- Book appointments with agents.\r\n- Receive real-time notifications when the price changes for a bookmarked property.\r\n- Update personal profile information.\r\n\r\nThe web application communicated with the REST API for all the data operations and connects to the SignalR server to receive notifications instantly. Customers who register through the web app are assigned the `USER` role by default.\r\n\r\n## System Implementation\r\n\r\n### Tech Stack\r\n\r\n- `Frontend (Web)`: Blazor\r\n- `Frontend (Desktop)`: JavaFX\r\n- `Backend (REST API)`: Java Spring Boot\r\n- `Real-time notifications`: SignalR\r\n- `Database`: PostgreSQL\r\n\r\n## Project Features\r\n\r\n### User authentication\r\n\r\n**Blazor web application for customers:**\r\n\r\n![Login page of the Blazor web application](/Blazor_Login.jpeg)\r\n\r\n![Registration page of the Blazor web application](/Blazor_Register.jpeg)\r\n\r\n**JavaFX desktop application for administrators:**\r\n\r\n![Login window of the JavaFX desktop application](/JavaFX_Login.png)\r\n\r\n![Registration window of the JavaFX desktop application](/JavaFX_Register.png)\r\n\r\n**Role-based authentication**\\\r\nThe system uses role-based authentication to manage access and permissions.\r\n\r\nThere are two distinct user roles: `USER` and `ADMIN`:\r\n\r\n- Customers who register for an account through the Blazor web application are automatically assigned the `USER` role.\r\n- Administrators who register through the JavaFX desktop application are automatically assigned the `ADMIN` role.\r\n\r\nAdministrators have additional privileges, such as managing property listings. Therefore, it is important to distinguish between administrators and customers. This ensures that customers cannot access API endpoints they are not authorized to use.\r\n\r\n**API endpoint security**\\\r\nAccess control is enforced by our Java REST API, which uses Spring Security to handle authentication and authorization.\r\nEndpoint security is achieved by using `@PreAuthorize(\"hasRole('ADMIN')\")` on endpoints that only administrators are allowed to access.\r\n\r\n### Manage property listings\r\n\r\nAdministrators can manage property listings through the JavaFX desktop application.\r\n\r\n**Create property**\\\r\nAdministrators can add new property listings by filling in the details such as price, address, property type, and upload images.\r\n\r\n**Update property information**\\\r\nDetails for existing property listings can be updated, such as changing the price.\r\n\r\n![Edit property window of the JavaFX desktop application](/JavaFX_Edit_Property.png)\r\n\r\nUploading additional images is also supported, as well as deleting existing images.\r\n\r\n![Image upload window of the JavaFX desktop application](/JavaFX_Edit_Property_Images.png)\r\n\r\n**Delete property**\\\r\nAdministrators can remove properties that are no longer available or relevant from the system entirely.\r\n\r\n### Bookmark property listings\r\n\r\nUsers can save properties as bookmarks to easily view them later.\r\nBookmarked properties are displayed on the `Account` page, where users can also remove bookmarks for listings they are no longer interested in.\r\n\r\n![Account page of the Blazor web application](/Blazor_Account.jpeg)\r\n\r\nWhen changes happen to bookmarked properties, the user will receive a notification.\r\nFor example, if the price is updated. In this case, the user will receive a notification about the new price of the property.\r\n\r\n### Manage agents\r\n\r\nAdministrators can manage real estate agents through the JavaFX desktop application. These agents are displayed in the Blazor web application, where customers can book them for property viewings and appointments.\r\n\r\n![Agent management window of the JavaFX desktop application](/JavaFX_Agent_List.png)\r\n\r\n**Add new agent**\\\r\nAdministrators can register new agents by providing the name and contact information. Once an agent has been added, they become available for booking on the web application.\r\n\r\n**Remove agent**\\\r\nAgents can be removed from the system if they are no longer active. This prevents customers from booking inactive agents.\r\n\r\n### Book an agent\r\n\r\n### Update user information\r\n\r\nUsers can update their information inside the Blazor web application by going to the `Account` page and then clicking on `Update Profile` button.\r\n\r\n![Update profile page of Blazor web application](/Blazor_Update_Profile.jpeg)\r\n\r\nFrom this view, users can change:\r\n\r\n- Username\r\n- Full name\r\n- Email address\r\n- Phone number\r\n- Address\r\n\r\nForm fields are pre-filled with the user's current information, making it easy to edit.\r\n\r\nAs a security measure, updating sensitive data such as the username or email address requires the user to enter their password. This is to prevent unauthorized changes in case the JWT session token is compromised.\r\n\r\n### Real-time notifications\r\n\r\nA SignalR server was implemented to handle real-time notifications.\r\nWhen a price change occurs, the Java REST server notifies the SignalR server, which then sends the real-time notification to the Blazor web application. This approach allows instant updates without requiring the user to refresh the page. SignalR was chosen for its speed and efficiency in delivering real-time notifications.\r\n"
  },
  {
    "slug": "pokemon-project",
    "title": "Pokémon Project",
    "date": "2025-04-08",
    "excerpt": "This project is the second assignment for my **WEB2** course. It is a Pokémon web app designed to display all Pokémon and their information such as height, weight, stats, and abilities.",
    "author": "Frederik Handberg",
    "coverImage": "/pokemon-list.png",
    "tags": [
      "Vite",
      "TypeScript",
      "React Router v7",
      "React Query",
      "TailwindCSS"
    ],
    "readingTime": "3 min read",
    "content": "\r\nGitHub repository: [https://github.com/frederikhandberg0709/pokemon-project](https://github.com/frederikhandberg0709/pokemon-project)\r\n\r\n## Tech Stack\r\n\r\n- **Build-Tool:** Vite\r\n- **Language:** TypeScript\r\n- **Routing:** React Router v7\r\n- **Data Fetching**: React Query\r\n- **Styling:** TailwindCSS\r\n- **API:** PokéAPI\r\n\r\n## Implementation\r\n\r\nI have two React Query hooks that I use to fetch Pokémon information from the PokéAPI.\r\n\r\nThe first hook is called `usePokemonList`. I use this to fetch all Pokémon. I also added support for pagination in this hook, as implementing pagination was one of the requirements for the assignment.\r\n\r\nI set the limit to 20, so that 20 Pokémon are displayed on each page.\r\nThe user can click on the \"Next\" button to go to the next page.\r\n\r\nThe second React Query hook I implement is called `usePokemonDetails`. The purpose of this hook is to fetch information for a specific Pokémon by providing its ID.\r\nOne caveat of the PokéAPI is that it does not provide the ID in the JSON objects. Instead, the ID can be extracted from the URL. I achieved this by implementing a utility function that I called `getPokemonIdFromUrl`.\r\n\r\nThis is not the only utility function I implemented. I ended up creating three utility functions in total.\r\n\r\n`getColorByPokemonId` is a utility function that assigns a color to each Pokémon depending on its ID. This function is being used in the Pokémon list. The color is simply assigned by calculation the remainder when dividing the ID by the number of types (which is 18).\r\n\r\nThe last utility function I implement is called `getPokemonImageUrl`. I wanted to display an image of the Pokémon. This can be done using the URL `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${id}.png`. Since I had already implemented the `getPokemonIdFromUrl` function, I was able to reuse it to extract the correct ID for the image URL.\r\n\r\nAs can be seen in the first image of the web app, the Pokémon cards all have the same layout, so for this I implemented a component called `PokemonCard`. The component needs five pieces of information:\r\n\r\n- **id** – The ID of the Pokémon, used to fetch the correct information for that specific Pokémon.\r\n- **number** – The ID displayed in the format of #5 if the ID is 5.\r\n- **name** – The name of the Pokémon.\r\n- **imageSrc** – The URL for the Pokémon's image.\r\n- **cardColor** – The background color of the card, based on the Pokémon’s ID.\r\n\r\n```tsx\r\n<PokemonCard\r\n  key={pokemon.id}\r\n  id={pokemon.id}\r\n  name={pokemon.name}\r\n  number={`#${getPokemonIdFromUrl(pokemon.url)}`}\r\n  imageSrc={getPokemonImageUrl(pokemon.url)}\r\n  cardColor={getColorByPokemonId(Number(pokemon.id))}\r\n/>\r\n```\r\n\r\nBesides supporting pagination, another requirement was to include at least two routes in our web app and use React Router to switch between the routes. Therefore, I added a second page to display detailed information about a specific Pokémon.\r\n\r\n![Pokémon details page](/pokemon-details.png)\r\n\r\nOn this page, I use the `usePokemonDetails` hook to fetch additional information about the Pokémon, beyond just the name and URL.\r\n"
  },
  {
    "slug": "social-network",
    "title": "Social Network",
    "date": "2025-03-22",
    "excerpt": "**BLOP** is a social network I created as a portfolio project, designed to closely mirror the functionality of modern social media platforms. My goal was to make it as realistic and feature-rich as possible, providing users with an experience they would expect from today's social networks.",
    "author": "Frederik Handberg",
    "coverImage": "/home.jpeg",
    "tags": [
      "Next.js",
      "TypeScript",
      "Prisma ORM",
      "Express",
      "Socket.IO"
    ],
    "readingTime": "9 min read",
    "content": "\r\nGitHub repository: [https://github.com/frederikhandberg0709/blop-social-media](https://github.com/frederikhandberg0709/blop-social-media)\r\n\r\n## Project Structure\r\n\r\nThis project is twofold, as it includes a **Next.js** project and an **Express.js** server.\r\n\r\n### Frontend & API (Next.js)\r\n\r\nThe frontend was built using Next.js. There are two main reasons for why I chose Next.js. First of all, it's a fullstack framework that makes it easy for a small team (in my case, just me), to work quickly and efficiently since it comes with most of the necessary tools out of the box. Secondly, the React documentations specifically recommend using Next.js.\r\n\r\nInstead of setting up a separate server (such as Express or Spring Boot), Next.js lets me build a REST server directly in the same project by using API routes.\r\n\r\n### Notification Service (Express.js)\r\n\r\nI mentioned earlier that one of the advantages of Next.js is that you might not need a separate server since it provides API routes. I did use API routes for all my HTTP calls.\r\n\r\nHowever, I wanted a notification service using Socket.IO. Technically, I could have built it directly in Next.js, but that would mean I couldn't use the default Next.js server – I would have to set up my own custom server in Next.js instead. Because of this, I decided it was better to have a separate Express.js server for the notification service.\r\n\r\nI chose Socket.IO mainly because I already have experience with SignalR from my third-semester project, and since Socket.IO is very similar to SignalR, it seemed like the obvious choice.\r\n\r\n## Project Features\r\n\r\nI have tried implementing the features that people expect from a modern social network. This includes the basic features such as being able to like and comment on posts, but also more advanced features, such as being able to switch accounts.\r\n\r\n### User Authentication\r\n\r\nI used NextAuth to build the authentication system, allowing users to log in with either their email or username and a password. For security, passwords are hashed using Argon2 before being stored in the database.\r\n\r\n![Login page](/login.jpeg)\r\n\r\n### Reset Password\r\n\r\nThe reset password functionality ensures that users can update their passwords if they forget it. Before submitting, the form performs validation checks:\r\n\r\n- If the new password meets security requirements\r\n- If the confirmation password matches the new password\r\n\r\nIf the validation passes, the request is sent to the API with the identifier (email or username) and the new password.\r\n\r\nOn the backend, in the API route, it searches for a user matching the provided identifier. If no user is found, it will return a \"User not found\" error.\r\n\r\nIf the user exists:\r\n\r\n- The new password is securely hashed using Argon2.\r\n- The hashed password is stored in the database, replacing the old one.\r\n- A success response is sent back.\r\n\r\nIn a real-world application, password resets should be handled more securely. Instead of allowing users to reset their password directly by providing their email or username, the system should send a reset link to the user's email with a token.\r\n\r\n![Reset password page](/reset-password.jpeg)\r\n\r\n### Bookmarks\r\n\r\nUsers can bookmark posts and comments they want to save for later. Bookmarks are stored in the database with a reference to the user who bookmarked it, so that the user can view their bookmarks on any device.\r\n\r\n![My bookmarks page](/my-bookmarks.jpeg)\r\n\r\n### Link Accounts\r\n\r\nUsers can link multiple accounts together. This allows switching between accounts without having to log in and out.\r\n\r\n![Link new account page](/link-new-account.jpeg)\r\n\r\nUsers can easily switch between their linked accounts by clicking on their profile menu and selecting the 'Switch Account' option, which will then display a list of all linked accounts.\r\n\r\n![Switch account widget in profile menu](/profile-menu_switch-account.png)\r\n\r\n### User Profile\r\n\r\nThe profile page includes a profile picture, banner, name, username, and a biography.  \r\nThis page also includes a timeline of the user's posts and counters for the number of followers, how many people the user is following, and the total number of posts from the user.\r\n\r\n![Profile page viewed by follower](/profile_follower.jpeg)\r\n\r\nThe user interface will slightly change depending on whether the user is the author of the profile or a follower. For example, if the user is the author, they will not see the 'Follow' button or notifications button. Instead, they will see an 'Edit Profile' button.\r\n\r\n![Profile page views by author](/profile_author.jpeg)\r\n\r\n### Quote Posts\r\n\r\nUsers can quote posts, which is similar to retweeting on Twitter. The original post is embedded in the new post.\r\n\r\n![Quoted post](/quoted-post.jpeg)\r\n\r\n### Notification System\r\n\r\nClicking the bell icon on a user profile, will show the notification settings to enable notifications whenever a user publishes a new post.\r\n\r\nClicking the 'Specific notifications' option, should allow the user to select which notifications they want to receive. Currently, only the 'New post' notification is working, but in the future, more options should be added.\r\n\r\n![Notification settings for profile](/profile-notification-settings.png)\r\n\r\nSocket.IO is only for sending notifications in real-time. This means, that the notifications would be lost if the user is not on the site. Therefore, notifications are also stored in the database, so that the user can see them when they return to the site.\r\n\r\nInitially, notifications are shown as unread. The user can then click on the notification to mark it as read.\r\n\r\nI should implement a dropdown menu to mark the notifications as read or delete them. Then clicking on the notification, should redirect the user to the post.\r\n\r\n![Notification panel](/notification-panel.png)\r\n\r\nThe notification panel could use some design improvements, particularly regarding timestamp formatting. Currently, timestamps display in a verbose format (e.g. \"9 seconds ago\"), which uses too much space in the compact panel. These should be converted to abbreviated formats (e.g. \"9s\") to take up less space.\r\n\r\nThe current implementation uses the same `formatDate` function that I developed for posts and comments. However, since the notification panel has more limited space than the posts, it requires a more concise timestamp format specifically made for the notification panel.\r\n\r\n## Future Development\r\n\r\nThere are some features and general improvements I would like to implement in the future.\r\n\r\n### Search functionality\r\n\r\nThere is currently a search input on the web application, but this is not functional. Users should be able to search for posts by keywords and hashtags, and to search for other users either by their profile name or username.\r\n\r\nIt should not be too difficult to implement this feature. I think one approach to implement this feature is by using URL params with the user's search input, then querying the database for posts or users that match the search input.\r\n\r\nHowever, the way I have set up the search input as of now, I would like the search results to update live as the user types. For this, the URL params approach would not be ideal.\r\n\r\nThe search functionality could be implemented client-side where the search results update in real-time as the user types, rather than using URL parameters.\r\n\r\nFirst of all, I should make sure to prevent excessive API calls as the user types. A small delay of about 300ms after the user has stopped typing could be made before sending the request to the API.  \r\nI already use React Query for data fetching, so I should just continue using that for the search functionality as well. It gives me caching and state management capabilities to handle search requests. This provides automatic loading states, error handling, and data caching.\r\n\r\nLastly, I will need to create a dedicated API route for searching posts and users, with filtering logic based on the search term.\r\n\r\n### Media upload\r\n\r\nUsers can add media (images and videos) to their posts.\r\n\r\nHowever, they must do this by linking to the media they want to include in their post or comment.\r\n\r\nThis is because it is not currently possible to upload media directly from the platform.\r\n\r\nThe media must be hosted elsewhere.\r\n\r\nIt would be much more ideal to allow users to upload their media directly on the platform.\r\n\r\nHow could this be implemented?\r\nInstead of storing the media files directly in the database, it’s best to store only metadata and file URLs.\r\n\r\nSo, we need a database table for the metadata and file URLs.\r\nAnd, it’s very important that the database table is storing a foreign key to the users table (who uploaded it) and a foreign key to the posts table (if attached to a post) or a foreign key to the comments table (if attached to a comment).\r\n\r\nWe need these foreign keys because otherwise, the system has no idea who uploaded the media or which post or comment it should be included in.\r\n\r\nAs stated earlier, storing media directly in a database table is less than ideal.\r\nThis means, the system needs a storage solution. In a real-world application, this could be done using AWS S3 as the storage solution.\r\n\r\nThe steps to upload media would be something like:\r\n\r\n1. The user uploads a file (this file is sent via `multipart/form-data`).\r\n2. Server should then process the file.\r\n   The server would need to make sure the file follows some guidelines.\r\n   For instance, there might be implemented a limit on how large the files are allowed to be, e.g. 5GB.\r\n\r\nThe server would also need to make sure the file type is allowed. Since this is for media uploads, it does not make sense to allow users to upload a `.txt` file.\r\n\r\nLastly, the server should make sure to save the metadata in the database table.\r\n\r\n### User interface improvements\r\n\r\nWhen I started working on this project, my goal was not to build a beautiful user interface. Instead, I wanted to focus on learning the technical aspects of building a modern and complex web application.\r\n\r\nI focused on understanding how to implement user authentication, efficiently fetch and mutate data, how to structure a large project, and leverage the features provided by React (e.g. hooks) and Next.js (e.g. API routes and the App Router).\r\n\r\nHowever, if I were to improve the visual design of the application, I would focus on implementing a light mode and ensuring that the UI looks good on all screen sizes.\r\n\r\nCurrently, the UI is optimized for desktop screens.\r\n"
  }
]